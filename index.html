<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å’’è¡“è¿´æˆ° & ä¸€æ‹³è¶…äººç‰¹æ•ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            background-color: #0f172a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            transition: background-color 0.1s ease; /* åŠ å¿«åˆ‡æ›é€Ÿåº¦ä»¥é…åˆæ‰“æ“Šæ„Ÿ */
        }
        
        /* --- èƒŒæ™¯ç‰¹æ•ˆç‹€æ…‹ --- */
        body.mode-purple { background-color: #1a0b2e; }
        body.mode-red { background-color: #2b0b0b; }
        body.mode-void { 
            background-color: #000000; 
            background-image: radial-gradient(white 1px, transparent 0);
            background-size: 40px 40px;
            filter: contrast(1.2);
        }
        /* ä¸€æ‹³è¶…äººæ¨¡å¼ï¼šé®®è±”çš„ç´…é»ƒé…è‰² */
        body.mode-punch {
            background: radial-gradient(circle, #facc15 0%, #ef4444 40%, #7f1d1d 100%);
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .input_video { display: none; }
        
        .output_canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            transform: scaleX(-1);
            transition: all 0.2s;
        }

        /* --- ç•«å¸ƒç‰¹æ•ˆå‹•ç•« --- */
        body.mode-purple .output_canvas {
            box-shadow: 0 0 60px 20px rgba(168, 85, 247, 0.5);
            animation: shake 0.5s infinite;
        }
        body.mode-red .output_canvas {
            box-shadow: 0 0 60px 20px rgba(239, 68, 68, 0.6);
            border: 2px solid #ef4444;
            animation: pulse-red 0.2s infinite;
        }
        body.mode-void .output_canvas {
            box-shadow: 0 0 100px 30px rgba(255, 255, 255, 0.3);
            filter: grayscale(100%) contrast(150%) brightness(1.2);
        }
        /* ä¸€æ‹³æ¨¡å¼ï¼šåŠ‡çƒˆéœ‡å‹• */
        body.mode-punch .output_canvas {
            box-shadow: 0 0 80px 40px rgba(255, 200, 0, 0.8);
            border: 5px solid #fff;
            animation: heavy-shake 0.2s infinite;
        }

        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .counter-card {
            margin-top: 20px;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(8px);
            padding: 1rem 2rem;
            border-radius: 1rem;
            border: 1px solid rgba(56, 189, 248, 0.3);
            text-align: center;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        /* ç‰¹æ•ˆè§¸ç™¼æ™‚éš±è—è¨ˆæ•¸å™¨ */
        body.mode-purple .counter-card,
        body.mode-red .counter-card,
        body.mode-void .counter-card,
        body.mode-punch .counter-card {
            opacity: 0;
            transform: translateY(-50px);
        }

        .count-number {
            font-size: 4rem;
            font-weight: 800;
            line-height: 1;
            color: #38bdf8;
        }

        /* --- è¡“å¼æ–‡å­—ç‰¹æ•ˆ --- */
        .technique-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 6rem;
            font-weight: 900;
            color: white;
            opacity: 0;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 50;
            white-space: nowrap;
            text-align: center;
            pointer-events: none;
        }

        body.mode-purple .technique-text {
            opacity: 1; transform: translate(-50%, -50%) scale(1);
            text-shadow: 0 0 20px #a855f7, 0 0 40px #7c3aed;
            content: "è™›å¼ã€Œç´«ã€";
        }
        
        body.mode-red .technique-text {
            opacity: 1; transform: translate(-50%, -50%) scale(1);
            color: #fee2e2;
            text-shadow: 0 0 20px #ef4444, 0 0 50px #b91c1c;
        }

        body.mode-void .technique-text {
            opacity: 1; transform: translate(-50%, -50%) scale(1.2);
            color: #000; -webkit-text-stroke: 2px #fff; text-shadow: 0 0 10px #fff;
            font-family: "Noto Serif TC", serif;
        }

        /* ä¸€æ‹³ç‰¹æ•ˆæ–‡å­— */
        body.mode-punch .technique-text {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1) rotate(-5deg);
            color: #ff0000;
            -webkit-text-stroke: 4px #fbbf24;
            text-shadow: 5px 5px 0px #000;
            font-style: italic;
        }

        @keyframes shake {
            0%, 100% { transform: scaleX(-1) translate(0, 0); }
            25% { transform: scaleX(-1) translate(2px, 2px); }
            75% { transform: scaleX(-1) translate(-2px, -2px); }
        }
        @keyframes pulse-red {
            0% { transform: scaleX(-1) scale(1); }
            50% { transform: scaleX(-1) scale(1.02); }
            100% { transform: scaleX(-1) scale(1); }
        }
        @keyframes heavy-shake {
            0% { transform: scaleX(-1) translate(0, 0) rotate(0deg); }
            20% { transform: scaleX(-1) translate(-10px, 10px) rotate(-2deg); }
            40% { transform: scaleX(-1) translate(10px, -10px) rotate(2deg); }
            60% { transform: scaleX(-1) translate(-10px, -10px) rotate(-2deg); }
            80% { transform: scaleX(-1) translate(10px, 10px) rotate(2deg); }
            100% { transform: scaleX(-1) translate(0, 0) rotate(0deg); }
        }

        .instruction-bar {
            position: absolute;
            bottom: 20px;
            display: flex;
            gap: 15px;
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            flex-wrap: wrap;
            justify-content: center;
        }
        .instruction-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: #e2e8f0;
        }
        .key-icon {
            font-weight: bold;
            color: #facc15;
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div class="canvas-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>

        <div class="ui-layer">
            <div class="counter-card">
                <div id="display-number" class="count-number">-</div>
                <div id="status-msg" class="text-sm text-gray-300 mt-2">å•Ÿå‹•ä¸­...</div>
            </div>
            
            <div id="tech-text" class="technique-text"></div>

            <div class="instruction-bar">
                <div class="instruction-item"><span class="key-icon">ğŸ‘Š</span> èªçœŸæ¯†æ‰“</div>
                <div class="instruction-item"><span class="key-icon">ğŸ–•</span> è™›å¼ã€Œç´«ã€</div>
                <div class="instruction-item"><span class="key-icon">ğŸ¤˜</span> è¡“å¼åè½‰ã€Œèµ«ã€</div>
                <div class="instruction-item"><span class="key-icon">ğŸ¤</span> ç„¡é‡ç©ºè™•</div>
            </div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');
        const displayNumber = document.getElementById('display-number');
        const statusMsg = document.getElementById('status-msg');
        const techText = document.getElementById('tech-text');
        const body = document.body;

        // æ‰‹æŒ‡ç‹€æ…‹åˆ¤æ–· (Tip Y < Pip Y)
        function isFingerExtended(landmarks, tipId, pipId) {
            return landmarks[tipId].y < landmarks[pipId].y;
        }

        // è·é›¢è¨ˆç®—
        function getDistance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        // --- æ‰‹å‹¢åˆ¤æ–·é‚è¼¯ ---

        // 4. ä¸€æ‹³è¶…äººï¼šæ‰€æœ‰æ‰‹æŒ‡å½æ›² (æ¡æ‹³)
        function checkOnePunch(landmarks) {
            // æª¢æŸ¥å››æ ¹æ‰‹æŒ‡æ˜¯å¦éƒ½æ”¶èµ· (ä½æ–¼ç¬¬äºŒé—œç¯€)
            // ç‚ºäº†è®“æ¡æ‹³æ›´å®¹æ˜“è§¸ç™¼ï¼Œå®¹éŒ¯ç‡è¨­é«˜ä¸€é» (-0.02)
            const benchmarkIndex = landmarks[6].y - 0.02;
            const benchmarkMiddle = landmarks[10].y - 0.02;
            const benchmarkRing = landmarks[14].y - 0.02;
            const benchmarkPinky = landmarks[18].y - 0.02;

            // åˆ¤æ–·æŒ‡å°–æ˜¯å¦ä½æ–¼(æ•¸å€¼å¤§æ–¼)é—œéµé»
            const indexFolded = landmarks[8].y > benchmarkIndex;
            const middleFolded = landmarks[12].y > benchmarkMiddle;
            const ringFolded = landmarks[16].y > benchmarkRing;
            const pinkyFolded = landmarks[20].y > benchmarkPinky;

            return indexFolded && middleFolded && ringFolded && pinkyFolded;
        }

        // 1. è™›å¼ã€Œç´«ã€
        function checkHollowPurple(landmarks) {
            const indexFolded = !isFingerExtended(landmarks, 8, 6);
            const middleExtended = isFingerExtended(landmarks, 12, 10);
            const ringFolded = !isFingerExtended(landmarks, 16, 14);
            const pinkyFolded = !isFingerExtended(landmarks, 20, 18);
            return middleExtended && indexFolded && ringFolded && pinkyFolded;
        }

        // 2. è¡“å¼åè½‰ã€Œèµ«ã€ (å¯¬é¬†ç‰ˆ)
        function checkRed(landmarks) {
            const indexExtended = isFingerExtended(landmarks, 8, 6);
            const pinkyExtended = isFingerExtended(landmarks, 20, 18);
            
            if (indexExtended && pinkyExtended) {
                const benchmarkY = landmarks[6].y - 0.03; 
                const middleTucked = landmarks[12].y > benchmarkY;
                const ringTucked = landmarks[16].y > benchmarkY;
                return middleTucked && ringTucked;
            }
            return false;
        }

        // 3. é ˜åŸŸå±•é–‹ã€Œç„¡é‡ç©ºè™•ã€
        function checkUnlimitedVoid(landmarks) {
            const indexExtended = isFingerExtended(landmarks, 8, 6);
            const middleExtended = isFingerExtended(landmarks, 12, 10);
            const ringFolded = !isFingerExtended(landmarks, 16, 14);
            const pinkyFolded = !isFingerExtended(landmarks, 20, 18);
            
            if (indexExtended && middleExtended && ringFolded && pinkyFolded) {
                const dist = getDistance(landmarks[8], landmarks[12]);
                if (dist < 0.05) return true; 
            }
            return false;
        }

        // è¨ˆç®—ä¸€èˆ¬æ•¸å­—
        function countFingers(landmarks, isRightHand) {
            let count = 0;
            const tipIds = [8, 12, 16, 20];
            const pipIds = [6, 10, 14, 18];
            for (let i = 0; i < tipIds.length; i++) {
                if (landmarks[tipIds[i]].y < landmarks[pipIds[i]].y) count++;
            }
            const thumbTipX = landmarks[4].x;
            const thumbIpX = landmarks[3].x;
            if (isRightHand) {
                if (thumbTipX < thumbIpX) count++;
            } else {
                if (thumbTipX > thumbIpX) count++;
            }
            return count;
        }

        // --- ç‰¹æ•ˆç¹ªè£½å‡½æ•¸ ---

        function drawPunchEffect(ctx, x, y) {
             const time = Date.now();
             
             // 1. è¡æ“Šæ³¢æ ¸å¿ƒ (äº®é»ƒè‰²)
             ctx.beginPath();
             ctx.arc(x, y, 80 + Math.random() * 20, 0, 2 * Math.PI);
             ctx.fillStyle = '#fef08a'; // yellow-200
             ctx.fill();
             
             // 2. ç´…è‰²å¤–åœˆçˆ†ç‚¸
             ctx.beginPath();
             ctx.arc(x, y, 120 + Math.random() * 30, 0, 2 * Math.PI);
             ctx.strokeStyle = '#ef4444'; // red-500
             ctx.lineWidth = 10;
             ctx.stroke();

             // 3. é€Ÿåº¦ç·š (é›†ä¸­ç·š)
             ctx.strokeStyle = '#fbbf24'; // amber-400
             ctx.lineWidth = 5;
             for (let i = 0; i < 12; i++) {
                 const angle = (i * 30 * Math.PI) / 180 + time * 0.01;
                 const startR = 100;
                 const endR = 1000; // å»¶ä¼¸åˆ°ç•«é¢å¤–
                 
                 ctx.beginPath();
                 ctx.moveTo(x + Math.cos(angle) * startR, y + Math.sin(angle) * startR);
                 ctx.lineTo(x + Math.cos(angle) * endR, y + Math.sin(angle) * endR);
                 ctx.stroke();
             }
        }

        function drawPurpleEffect(ctx, x, y) {
            const time = Date.now() / 200;
            const radius = 50 + Math.sin(time) * 10;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.4, 'rgba(168, 85, 247, 1)');
            gradient.addColorStop(1, 'rgba(88, 28, 135, 0)');
            
            ctx.beginPath();
            ctx.arc(x, y, radius * 1.5, 0, 2 * Math.PI);
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.strokeStyle = '#e9d5ff';
            ctx.lineWidth = 3;
            for(let i=0; i<5; i++) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                const angle = Math.random() * Math.PI * 2;
                const len = radius * 2;
                ctx.quadraticCurveTo(
                    x + Math.cos(angle)*len*0.5 + Math.random()*20, 
                    y + Math.sin(angle)*len*0.5 + Math.random()*20, 
                    x + Math.cos(angle)*len, 
                    y + Math.sin(angle)*len
                );
                ctx.stroke();
            }
        }

        function drawRedEffect(ctx, x, y) {
            const time = Date.now() / 100;
            const radius = 40 + Math.random() * 20;

            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
            gradient.addColorStop(0.5, 'rgba(239, 68, 68, 0.9)');
            gradient.addColorStop(1, 'rgba(153, 27, 27, 0)');

            ctx.beginPath();
            ctx.arc(x, y, radius * 2 + (time % 10) * 10, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(239, 68, 68, ${1 - (time%10)/10})`;
            ctx.lineWidth = 4;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = gradient;
            ctx.fill();
        }

        function drawVoidEffect(ctx, landmarks) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 1;
            for (let i = 0; i < landmarks.length; i++) {
                for (let j = i + 1; j < landmarks.length; j++) {
                    const p1 = landmarks[i];
                    const p2 = landmarks[j];
                    const dist = getDistance(p1, p2);
                    if (dist < 0.15) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x * canvasElement.width, p1.y * canvasElement.height);
                        ctx.lineTo(p2.x * canvasElement.width, p2.y * canvasElement.height);
                        ctx.stroke();
                    }
                }
            }
        }

        function onResults(results) {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            let currentTechnique = 'NONE';
            let techniquePoint = {x: 0, y: 0};
            let totalFingers = 0;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    
                    // å„ªå…ˆæ¬Šåˆ¤æ–·: ä¸€æ‹³ > é ˜åŸŸå±•é–‹ > èµ« > ç´« > æ™®é€šè¨ˆæ•¸
                    // æ³¨æ„ï¼šæ¡æ‹³(checkOnePunch) èˆ‡ ç„¡é‡ç©ºè™•(checkUnlimitedVoid) äº’æ–¥ (æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´)
                    
                    if (checkOnePunch(landmarks)) {
                        currentTechnique = 'PUNCH';
                        // æ‹³é ­ä¸­å¿ƒ (å–ä¸­æŒ‡æ ¹éƒ¨)
                        techniquePoint = {x: landmarks[9].x * canvasElement.width, y: landmarks[9].y * canvasElement.height};
                        // ç•«å‡ºå……æ»¿åŠ›é‡çš„éª¨æ¶
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#facc15', lineWidth: 8});
                        drawPunchEffect(canvasCtx, techniquePoint.x, techniquePoint.y);
                        
                    } else if (checkUnlimitedVoid(landmarks)) {
                        currentTechnique = 'VOID';
                        techniquePoint = {x: landmarks[8].x * canvasElement.width, y: landmarks[8].y * canvasElement.height};
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 2});
                        drawVoidEffect(canvasCtx, landmarks);
                        
                    } else if (checkRed(landmarks)) {
                        currentTechnique = 'RED';
                        techniquePoint = {x: landmarks[9].x * canvasElement.width, y: landmarks[9].y * canvasElement.height};
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#ef4444', lineWidth: 4});
                        drawRedEffect(canvasCtx, techniquePoint.x, techniquePoint.y);
                        
                    } else if (checkHollowPurple(landmarks)) {
                        currentTechnique = 'PURPLE';
                        techniquePoint = {x: landmarks[12].x * canvasElement.width, y: landmarks[12].y * canvasElement.height};
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#a855f7', lineWidth: 4});
                        drawPurpleEffect(canvasCtx, techniquePoint.x, techniquePoint.y);
                        
                    } else {
                        // æ™®é€šè¨ˆæ•¸æ¨¡å¼
                        let label = 'Right';
                        if (results.multiHandedness && results.multiHandedness[i]) label = results.multiHandedness[i].label;
                        
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
                        drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2});
                        totalFingers += countFingers(landmarks, label === 'Right');
                    }
                }
            }

            // æ›´æ–° UI ç‹€æ…‹
            body.className = ''; 
            techText.innerText = '';
            
            if (currentTechnique === 'PUNCH') {
                body.classList.add('mode-punch');
                techText.innerText = 'å¿…æ®º\nèªçœŸæ¯†æ‰“';
            } else if (currentTechnique === 'VOID') {
                body.classList.add('mode-void');
                techText.innerText = 'é ˜åŸŸå±•é–‹\nç„¡é‡ç©ºè™•';
            } else if (currentTechnique === 'RED') {
                body.classList.add('mode-red');
                techText.innerText = 'è¡“å¼åè½‰ã€Œèµ«ã€';
            } else if (currentTechnique === 'PURPLE') {
                body.classList.add('mode-purple');
                techText.innerText = 'è™›å¼ã€Œç´«ã€';
            } else {
                if (results.multiHandLandmarks.length > 0) {
                    displayNumber.innerText = totalFingers;
                    statusMsg.innerText = "åµæ¸¬åˆ°æ‰‹æŒ‡";
                } else {
                    displayNumber.innerText = "-";
                    statusMsg.innerText = "è«‹å°‡æ‰‹æ”¾å…¥é¡é ­";
                }
            }

            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280,
            height: 720
        });
        camera.start();
    </script>
</body>
</html>